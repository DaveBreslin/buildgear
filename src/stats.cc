/*
 * This file is part of Build Gear.
 *
 * Copyright (c) 2013  Jesper Larsen
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

#include <thread>
#include <chrono>
#include <stdlib.h>
#include <sys/sysinfo.h>
#include <iostream>
#include <iomanip>
#include <sstream>
#include <string.h>
#include "config.h"
#include "buildgear/stats.h"
#include "buildgear/config.h"

static unsigned long long lastTotalUser, lastTotalUserLow, lastTotalSys, lastTotalIdle;
struct sysinfo memInfo;

double getCurrentUsageCPU(){
   static double percent = 0.0;
   FILE* file;
   unsigned long long totalUser, totalUserLow, totalSys, totalIdle, total;

   file = fopen("/proc/stat", "r");
   if (!file)
   {
      cout << "\nError: Could not open /proc/stat";
      cout << endl << strerror(errno) << endl;
      exit(EXIT_FAILURE);
   }
   if(fscanf(file, "cpu %Ld %Ld %Ld %Ld", &totalUser, &totalUserLow,
         &totalSys, &totalIdle) < 4)
   {
      fclose(file);
      return percent;
   }
   fclose(file);


   if (totalUser < lastTotalUser || totalUserLow < lastTotalUserLow ||
         totalSys < lastTotalSys || totalIdle < lastTotalIdle){
      // Overflow detection. Just skip this value.
      percent = 0.0;
   }
   else{
      total = (totalUser - lastTotalUser) + (totalUserLow - lastTotalUserLow) +
         (totalSys - lastTotalSys);
      // Check for possible division by zero
      if (total + (totalIdle - lastTotalIdle) == 0)
         return percent;
      percent = total;
      total += (totalIdle - lastTotalIdle);
      percent /= total;
      percent *= 100;
   }

   lastTotalUser = totalUser;
   lastTotalUserLow = totalUserLow;
   lastTotalSys = totalSys;
   lastTotalIdle = totalIdle;

   return percent;
}

double getCurrentUsageMem(void)
{
   sysinfo (&memInfo);

   double physMemUsed = memInfo.totalram - memInfo.freeram;
   return physMemUsed / memInfo.totalram * 100.0;
}

void captureStats(CStats *Stats)
{
   chrono::seconds sleeptime(LOAD_CHART_RESOLUTION);
   FILE* file = fopen("/proc/stat", "r");

   if (fscanf(file, "cpu %Ld %Ld %Ld %Ld", &lastTotalUser, &lastTotalUserLow,
         &lastTotalSys, &lastTotalIdle) < 4)
   {
      fclose(file);
      lastTotalUser = 0;
      lastTotalUserLow = 0;
      lastTotalSys = 0;
      lastTotalIdle = 0;
   }
   fclose(file);

   while(Stats->capture)
   {
      Stats->cpu_usage.push_back(getCurrentUsageCPU());
      Stats->mem_usage.push_back(getCurrentUsageMem());
      this_thread::sleep_for(sleeptime);
   }
}

void CStats::enableCapture()
{
   this->capture = true;
   this->captureThread = new thread(captureStats, this);
}

void CStats::disableCapture()
{
   this->capture = false;
}

string CStats::averageCPULoad(void)
{
   float average = 0;
   ostringstream result;
   vector<float>::iterator it;

   for (it = cpu_usage.begin(); it != cpu_usage.end(); it++)
        average += *it;

   average = average / cpu_usage.size();

   result << fixed << setprecision(1) << average;

   return result.str();
}

string CStats::maxMemoryUsage(void)
{
   float max_usage = 0;
   ostringstream result;
   vector<float>::iterator it;

   for (it = mem_usage.begin(); it != mem_usage.end(); it++)
      if (*it > max_usage)
        max_usage = *it;

   result << fixed << setprecision(1) << max_usage;

   return result.str();
}

string CStats::minMemoryUsage(void)
{
   float min_usage;
   ostringstream result;
   vector<float>::iterator it;

   min_usage = mem_usage[0];

   for (it = mem_usage.begin(); it != mem_usage.end(); it++)
      if (*it < min_usage)
        min_usage = *it;

   result << fixed << setprecision(1) << min_usage;

   return result.str();
}

void CStats::saveCapture(string filename)
{
   int i;
   float bar_width;
   int seconds;
   int minutes;
   float pos;

   if (cpu_usage.empty())
      return;

   bar_width = LOAD_CHART_WIDTH / cpu_usage.size();

   this->svg.open(filename);
   // Set up header
   this->svg.addNaked("<svg version='1.1' xmlns='http://www.w3.org/2000/svg'>");
   this->svg.addNaked("<!-- Autogenerated by Build Gear v" VERSION " (http://www.buildgear.org/) -->");
   this->svg.addNaked("<g transform='scale(2)'>");
   this->svg.addRectangle("0", "0", "100%", "100%", "fill:white");
   this->svg.addText("Build Gear - Load Chart",
         (LOAD_CHART_WIDTH + 2 * LOAD_CHART_MARGIN) / 2, LOAD_CHART_LINE_HEIGHT, "black",
         "font-size='8' text-anchor='middle'");
   this->svg.addText("Build: " + Config.name + " (parallel_builds="
         + Config.bg_config["parallel_builds"] + ")",
         (LOAD_CHART_WIDTH + 2 * LOAD_CHART_MARGIN) / 2,
         2 * LOAD_CHART_LINE_HEIGHT, "black", "font-size='7' text-anchor='middle'");

   // Add average system CPU usage and max/min system memory usage
   this->svg.addText("Average System CPU Usage: " + averageCPULoad() + "%            " +
                     "Maximum System Memory Usage: " + maxMemoryUsage() + "%            " +
                     "Minimum System Memory Usage: " + minMemoryUsage() + "%",
                     (LOAD_CHART_WIDTH + 2 * LOAD_CHART_MARGIN) / 2,
                     34 * LOAD_CHART_LINE_HEIGHT, "black", "font-size='6' text-anchor='middle' xml:space='preserve'");

   // Graph for system CPU usage
   this->svg.addNaked("<g transform='translate(" +
         to_string(LOAD_CHART_MARGIN + LOAD_CHART_LINE_HEIGHT) + "," +
         to_string(((LOAD_CHART_HEIGHT + 2) / 2) + LOAD_CHART_MARGIN +
                   2 * LOAD_CHART_LINE_HEIGHT) + ")'>");
   this->svg.addText("System CPU Usage [%]", 0, -2, "black",
         "text-anchor='middle' font-size='5' transform='rotate(-90)'");
   this->svg.addNaked("</g>");
   this->svg.addRectangle(LOAD_CHART_MARGIN + 1.5 * LOAD_CHART_LINE_HEIGHT - 1,
         LOAD_CHART_MARGIN + 2 * LOAD_CHART_LINE_HEIGHT,
         LOAD_CHART_WIDTH + 2, LOAD_CHART_HEIGHT, "stroke:black;fill:black;fill-opacity:0.2");

   // Graph for system memory usage
   this->svg.addNaked("<g transform='translate(" +
         to_string(LOAD_CHART_MARGIN + LOAD_CHART_LINE_HEIGHT) + "," +
         to_string(((LOAD_CHART_HEIGHT + 2) / 2) + 3 * LOAD_CHART_MARGIN +
            2 * LOAD_CHART_LINE_HEIGHT + LOAD_CHART_HEIGHT) + ")'>");
   this->svg.addText("System Memory Usage [%]", 0, -2, "black",
         "text-anchor='middle' font-size='5' transform='rotate(-90)'");
   this->svg.addNaked("</g>");
   this->svg.addRectangle(LOAD_CHART_MARGIN + 1.5 * LOAD_CHART_LINE_HEIGHT - 1,
         3 * LOAD_CHART_MARGIN + 2 * LOAD_CHART_LINE_HEIGHT + LOAD_CHART_HEIGHT,
         LOAD_CHART_WIDTH + 2, LOAD_CHART_HEIGHT, "stroke:black;fill:black;fill-opacity:0.2");

   // Add margins in bottom and right
   this->svg.addRectangle(to_string(LOAD_CHART_MARGIN + 1.5 * LOAD_CHART_LINE_HEIGHT +
         LOAD_CHART_WIDTH + 3), "0", to_string(LOAD_CHART_MARGIN), "100%", "fill:white");
   this->svg.addRectangle("0", to_string(3 * LOAD_CHART_MARGIN + 3 * LOAD_CHART_LINE_HEIGHT +
            2 * LOAD_CHART_HEIGHT), "100%", to_string(LOAD_CHART_MARGIN), "fill:white");

   // Translage to the upper left corner of CPU graph
   this->svg.addNaked("<g transform='translate(" +
         to_string(LOAD_CHART_MARGIN + 1.5 * LOAD_CHART_LINE_HEIGHT - 1) +
         "," + to_string(LOAD_CHART_MARGIN + 2 * LOAD_CHART_LINE_HEIGHT) + ")'>");

   // Draw X axis labels and grid
   for (i = 0; i <= LOAD_CHART_XLINES; i++)
   {
      pos = i * ((LOAD_CHART_WIDTH + 2) / LOAD_CHART_XLINES);
      this->svg.addLine(pos, 0, pos, LOAD_CHART_HEIGHT, "stroke:black;opacity:0.7");
      this->svg.addLine(pos, LOAD_CHART_HEIGHT + 2 * LOAD_CHART_MARGIN,
            pos, 2 * LOAD_CHART_HEIGHT + LOAD_CHART_MARGIN + LOAD_CHART_LINE_HEIGHT + 2,
            "stroke:black;opacity:0.7");
      seconds = i * cpu_usage.size() / LOAD_CHART_XLINES * LOAD_CHART_RESOLUTION;
      minutes = 0;
      while (seconds >= 60)
      {
         seconds -= 60;
         minutes++;
      }
      this->svg.addText(to_string(minutes) + "m " + to_string(seconds) + "s",
            pos, LOAD_CHART_HEIGHT + LOAD_CHART_LINE_HEIGHT,
            "black", "text-anchor='middle' font-size='4'");
      this->svg.addText(to_string(minutes) + "m " + to_string(seconds) + "s",
            pos, 2 * LOAD_CHART_HEIGHT + 2 * LOAD_CHART_MARGIN + LOAD_CHART_LINE_HEIGHT,
            "black", "text-anchor='middle' font-size='4'");
   }

   this->svg.addNaked("</g>");

   // Translate to lower left corner of CPU graph
   this->svg.addNaked("<g transform='translate(" +
         to_string(LOAD_CHART_MARGIN + 1.5 * LOAD_CHART_LINE_HEIGHT) +
         "," + to_string(LOAD_CHART_MARGIN + 2 * LOAD_CHART_LINE_HEIGHT +
            LOAD_CHART_HEIGHT - 1) + ")'>");

   // Draw data points
   for (i = 0; i < this->cpu_usage.size(); i++)
   {
      int temp;
      this->svg.addRectangle(i * bar_width, 0, bar_width, cpu_usage[i] * ((LOAD_CHART_HEIGHT - 2) / -100.0),
            "fill:blue;stroke-width:1;stroke:blue");
      this->svg.addRectangle(i * bar_width, LOAD_CHART_HEIGHT + LOAD_CHART_MARGIN +
            LOAD_CHART_LINE_HEIGHT + 2, bar_width, mem_usage[i] * ((LOAD_CHART_HEIGHT - 2) / -100.0),
            "fill:red;stroke-width:1;stroke:red");
   }

   this->svg.addNaked("</g>");
   this->svg.addNaked("</g>");
   this->svg.addNaked("</svg>");

   this->svg.close();

   cout << "Saved load chart to " << filename << endl;
}
